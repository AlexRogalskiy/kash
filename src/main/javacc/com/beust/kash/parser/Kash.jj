options {
    STATIC = false ;
    DEBUG_PARSER = false;
}

PARSER_BEGIN(KashParser)

package com.beust.kash.parser;

import java.util.List;
import java.util.ArrayList;

public class KashParser {
    private static boolean eq(Object a, Object b) {
        return (a == null && b == null) || (a != null && a.equals(b));
    }

    public static class RedirectionNode {
        public final String symbol;
        public final String destination;
        RedirectionNode(String symbol, String destination) { this.symbol = symbol; this.destination = destination; }
    }

    public static class AbstractCommand<T> {
        public final T content;
        public AbstractCommand(T content) { this.content = content; }
    }

    public static class Command {
        public final SimpleCommand simpleCommand;
        public final SubShell subShell;
        public Command(SimpleCommand sc, SubShell ss) {
            this.simpleCommand = sc; this.subShell = ss;
        }
        @Override public boolean equals(Object other) {
            Command c = (Command) other;
            return simpleCommand.equals(c.simpleCommand) && subShell == c.subShell;
        }
    }

    public static class SimpleCommand {
        public final List<String> content;
        public final String input;
        public final String output;
        public final String before;
        public SimpleCommand(List<String> content, String input, String output, String before) {
            this.content = content; this.input = input; this.output = output; this.before = before;
        }
        public SimpleCommand(List<String> content, String input, String output) {
            this(content, input, output, null);
        }
        @Override public boolean equals(Object other) {
            SimpleCommand sc = (SimpleCommand) other;
            return content.equals((sc.content)) &&
                eq(input, sc.input) &&
                eq(output, sc.output) &&
                eq(before, sc.before);
        }
    }

    public static class CompoundList extends AbstractCommand<List<SimpleCommand>> {
        public CompoundList(List<SimpleCommand> content) { super(content); }
        @Override public boolean equals(Object other) {
            CompoundList cl = (CompoundList) other;
            return this.content.equals(cl.content);
        }
    }

    public static class PipeLineCommand extends AbstractCommand<List<Command>> {
        public final String precededBy;
        public PipeLineCommand(List<Command> content, String precededBy) {
            super(content);
            this.precededBy = precededBy;
        }
        @Override public boolean equals(Object other) {
            PipeLineCommand cl = (PipeLineCommand) other;
            return eq(precededBy, cl.precededBy) && content.equals(cl.content);
        }
    }

    public static class SubShell {
        public final KashParser.CompoundList command;
        public SubShell(KashParser.CompoundList command) {
            this.command = command;
        }
        @Override public boolean equals(Object other) {
            SubShell ss = (SubShell) other;
            return command.equals(ss.command);
        }
    }


//    public static class SingleCommand extends AbstractCommand<List<String>> {
//        public SingleCommand(List<String> content, String input, String output) { super(content); }
//    }
//
    public static class SimpleList extends AbstractCommand<List<PipeLineCommand>> {
        public final boolean ampersand;
        public SimpleList(List<PipeLineCommand> pipelines, boolean ampersand) {
            super(pipelines);
            this.ampersand = ampersand;
        }
    }

//    public static class AndAndCommand {
//        public AndAndCommand(List<List<String>> content) { super(content); }
//    }
}

PARSER_END(KashParser)

SKIP:  { " " | "\t" | "\n" | "\r"                    }
TOKEN: {
    "(" | ")" | <GT: ">"> | <LT: "<"> | <ANDAND: "&&"> | <PIPE: "|"> | <NUM: (["0"-"9"])+>
    | <WORD: (["-", ".", "a"-"z", "A"-"Z"]) +>
     }

SimpleList SimpleList():
{
    List<PipeLineCommand> cs;
    boolean ampersand = false;
    SimpleList result;
}
{
    (cs = SimpleList1()) ("&" { ampersand = true; })?
    {
        return new SimpleList(cs, ampersand);
    }
}

List<PipeLineCommand> SimpleList1():
{
    PipeLineCommand c;
    List<PipeLineCommand> cs;
    List<PipeLineCommand> result = new ArrayList<PipeLineCommand>();
}
{
    c = PipeLineCommand() { result.add(c); }
        ("&&" cs = SimpleList1()
        {
            for (PipeLineCommand pc: cs) {
                result.add(new PipeLineCommand(pc.content, "&&"));
            }
        })*

    {
        return result;
    }

}


KashParser.SimpleCommand SimpleCommand():
{
    RedirectionNode redir = null;
    Token w = null;
    String input = null;
    String output = null;
    List<String> words = new ArrayList<String>();
}
{
    (w = <WORD> { words.add(w.image); })+
    (redir = Redirection() {
        switch(redir.symbol) {
            case(">"): output = redir.destination; break;
            case("<"): input= redir.destination; break;
        }
     }
    )*
    {
        return new KashParser.SimpleCommand(words, input, output);
    }
}

Command Command():
{
    SimpleCommand sc;
    SubShell ss;
    Command result;
}
{
    (
    ( sc = SimpleCommand() { result = new Command(sc, null); })
    |
    ss = SubShell() { result = new Command(null, ss); }
    <EOF>
    )
    {
    return result;
    }
}

RedirectionNode Redirection():
{
    Token c = null;
    Token t = null;
}
{
    (c = ">" t = <WORD> | c = "<" t = <WORD>)
    {
        return new KashParser.RedirectionNode(c.image, t.image);
    }
}

KashParser.SubShell SubShell():
{
    CompoundList result = null;
}
{
    "(" result = CompoundList() ")"
    {
        return new SubShell(result);
    }
}

CompoundList CompoundList():
{
    KashParser.SimpleCommand c = null;
    List<SimpleCommand> commands = new ArrayList<SimpleCommand>();
}
{
    (c = SimpleCommand() { commands.add(c); }
        ("&&" c = SimpleCommand() { commands.add(new SimpleCommand(c.content, c.input, c.output, "&&")); })*
    )
    {
        return new KashParser.CompoundList(commands);
    }
}

PipeLineCommand PipeLineCommand():
{
    Command c;
    List<Command> commands = new ArrayList<Command>();
}
{
    c = Command() { commands.add(c); }
        ("|" c = Command() { commands.add(c); })*
    {
        return new PipeLineCommand(commands, null);
    }

}
